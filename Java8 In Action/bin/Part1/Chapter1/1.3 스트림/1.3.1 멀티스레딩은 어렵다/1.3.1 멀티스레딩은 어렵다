1. 이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다.

2.멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다.
결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.
멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다.
(전통적으로 멀티스레딩 환경에서는 synchronized를 자주 활용한다. 
synchronized를 활용해도 많은 미묘한 버그가 발생한다. 
자바 8에서는 synchronized가 필요 없는 함수형 프로그래밍 형식의 스트림 기반 병렬성을 이용하도록 권고하며, 
데이터 접근 방법을 제어 하는게 아니라 어떻게 데이터를 분할할지 고민하게 된다.)

3. 자바 8에서는 스트림 API(java.util.stream)로
	- 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제
	- 멀티코어 활용 어려움
등 2가지 문제를 모두 해결했다.

4. 기존의 컬렉션에서는 데이터를 처리할 때 반복 되는 패턴을 주어진 조건에 따라 
	- 데이터를 필터링(filtering)하거나(예로 무게에 따라 사과를 선택.)
	- 데이터를 추출(extracting)하거나(예로 리스트에서 각 사과의 무게 필드를 추출.)
	- 데이터를 그룹화(grouping)(예로 숫자 리스트의 숫자를 홀수와 짝수로 그룹화.)
등의 기능이 있다.

5. 리스트를 필터링 한다는 가정하에 스트림의 병렬화는
	1. 포크 (혹은 포킹 단계(forking step))
		- 리스트 데이터를 각 CPU에 배분.
	2. 필터
		- 배분 받은 각 CPU에서 리스트 데이터를 필터 처리.
	3. 결과 합침
		- 각 CPU에서 처리한 결과를 하나로 정리.
와 같은 흐름을 가지게 된다.

6. 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면
스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.

7. 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심이다.

8.
	improt static java.util.stream.Collectors.toList;
	List<Apple> heavyApples = inventory.stream()
		.filter((Apple a) -> a.getWeight() > 150)
		.collect(toList());
	위 방식은 순차 처리 방식의 코드이다.
	
	improt static java.util.stream.Collectors.toList;
	List<Apple> heavyApples = inventory.parallelStream()
		.filter((Apple a) -> a.getWeight() > 150)
		.collect(toList());	
	위 방식은 병렬 처리 방식의 코드이다.
	
	stream, parallelStream 메서드 중 어떤 메서드를 쓰느냐에 따라서
	순차, 병렬 처리 방식인지 지정 할 수 있다. 

부록
	자바의 병렬성과 공유되지 않는 가변 상태
		자바는 병렬 처리를 위해 두 가지 요술방망이를 제공한다.
		1. 라이브러리에서 분할 처리 한다.
			큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다.
		2. filter 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 
		가변 공유 객체를 통해 꽁짜로 병렬성을 누릴 수 있다.
			함수형 프로그래밍에서 함수형이란 '함수를 일급값으로 사용한다'라는 의미도 있지만
			부가적으로 '프로그램이 실행되는 동안 컴포넌트 간에 상효작용이 일어나지 않는다'라는 의미도 포함한다.